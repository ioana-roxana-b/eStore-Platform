For the first two requirements, I implemented the missing methods in the data structures. 
The most challenging part for these initial requirements was getting accustomed to the hierarchies and how the classes were designed. 
This aspect was particularly intriguing as it required adapting our solutions based on existing structures.

For the third requirement, I utilized the "utility" class to implement helper functions and leveraged the User and Product lists created in Task 2.
 For 3a, I searched the list for all discounted espresso machines and inserted them into a new list, which I then returned. 
For 3b, I employed a similar approach to 3a, but this time I needed to use dynamic_cast. 
For 3c, I created a sorting function in "utility.cpp" based on price, which I called after creating a new list and inserting all refurbished products with the reason "missing_accessories." 
For 3d, I followed a similar approach as the previous subtask, but this time in the sorting function, I had to consider all specified aspects. 
For 3e, to find the county with the most inhabitants, I created a function in "utility" using an occurrences vector, returning the county based on the maximum occurrences. 
In the last query, I stored in a vector the IDs of the products belonging to the categories "phone" or "printer," then traversed the user list to find individuals meeting the conditions mentioned in the requirement.

For requirement 4, I implemented the requested methods, and the one that seemed a bit more challenging was "processRequests." 
Regarding requirement 5, to solve this task, I followed a similar approach for both methods. 
First, I ensured that the quantity was greater than 0. Then, I searched the User/Product list for the given ID as a parameter and checked if the requested quantity was available. 
If all conditions were met, I traversed the User/Product list, and based on the required addition/removal, I called the already implemented methods in the other classes.
